# Лабораторная №3 (`WW_mergesort`)

## Содержание
1. [Содержание](#содержание)
1. [Задание](#задание)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Стандартные требования](#стандартные-требования)
    1. [Прочие требования](#прочие-требования)
    1. [Обобщённая сортировка](#обобщённая-сортировка)
    1. [Консольное приложение](#консольное-приложение)
    1. [Структура репозитория](#структура-репозитория)
    1. [Бонусное задание](#бонусное-задание)
1. [Сроки сдачи](#сроки-сдачи)

## Задание
Реализуйте алгоритм [сортировки слиянием](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B5%D0%BC)
(merge sort), способный работать для произвольных типов данных в языке Си.
Реализация должна находиться в файлах `mergesort.h` и `mergesort.c`.

Затем в файле `main.c` реализуйте консольное приложение, которое сортирует
переданные в качестве аргументов командной строки данные и печатает отсортированный массив.

## Требования к корректности решения
### Стандартные требования
Смотри стандартные требования из третьей лабораторной, название папки и файла — `lab_03`.
Также добавляются новые, которые будут действовать во всех будущих лабораторных.

Обязательно сделать хотя бы одну попытку сдачи лабораторной до промежуточного
[срока сдачи](#сроки-сдачи), в которой будет хотя бы
корректная [структура репозитория](#структура-репозитория) с собирающимся кодом.
Полная корректность решения или стиль в этот момент не требуется, но рекомендуется.
В противном случае вы автоматически получаете за задание **ноль баллов, даже если** позже
дошлёте правильную версию.

Требования на автоматические тесты остаются, но неактуальны, потому что автоматические тесты
в задании реализовывать не надо.

Так как в задании не требуются автоматические тесты, при желании вы можете реализовать свои в файле `test.c`, который
по команде `make test` собирает отдельный исполняемый файл `test`, который по команде
`make clean` удаляется вместе с остальными артефактами сборки.
В этом случае:
* На корректность влияет только содержимое `Makefile`, сами тесты могут быть сколь угодно некорректными.
* Баллы за стиль не меняются, но преподаватель может на своё усмотрение прокомментировать стиль в `test.c`.

### Прочие требования
* Все операции, связанные с копированием памяти, надо реализовать самостоятельно.
* В файлах `mergesort.c` и `mergesort.h` не должно быть предположений о размере массива или объектов,
  а также предположений о внутреннем устройстве сортируемого типа данных
  (кроме факта, что его значения можно копировать побайтово в любое место памяти независимо ни от чего).
* В файле `main.c` не должно быть никаких кусочков сортировки, кроме нескольких реализаций
  функции сравнения двух элементов.

### Обобщённая сортировка
Предполагается, что каждый элемент занимает фиксированное количество байт в памяти,
а сами элементы для сортировки лежат в массиве подряд.

Требуемая сигнатура единственной функции в `mergesort.h`:

```
void mergesort(void *array, size_t elements, size_t element_size, int (*comparator)(const void*, const void*));
```

Ей передаются следующие параметры:

* `array` — указатель на начало массива. Так как тип данных неизвестен, это указатель на `void`.
* `elements` — количество элементов в массиве.
* `element_size` — размер одного элемента в массиве.
* `comparator` — указатель на функцию, которая умеет сравнивать два элемента по константным указателям на них.
  Эта функция знает тип данных, который ей передают, однако её параметры всё равно
  имеют тип `void*`, потому что его надо зафиксировать в файле `mergesort.h`.
  `comparator(a, b)` ведёт себя аналогично `strcmp`: возвращает ноль, если `a` и `b`
  эквивалентны с точки зрения сортировки,
  отрицательное число, если `a` должно стоять до `b` в отсортированном массиве,
  и положительное число иначе.

Если какой-нибудь из аргументов некорректен (например, `comparator` не задаёт
отношение полного порядка на классах эквивалентности элементов), то поведение,
как обычно, не определено.

В процессе работы функции вам наверняка потребуется временный буфер.
Воспользуйтесь `malloc`, убедитесь с помощью `assert` в успешности выделения памяти.

Пример вызова:

```
// int greater than comparator
int int_gt_comparator(const void *a, const void *b) {
    return *(int*)b - *(int*)a;  // Сортировка массива по убыванию.
}
// ...
int data[] = { 3, 1, 2 };
mergesort(data, sizeof data / sizeof data[0], sizeof data[0], int_gt_comparator);
```

### Консольное приложение
В качестве аргументов командной строки (смотри параметры `argc` и `argv` у `main()`) приложению передаются:

1. Аргумент №1: тип элементов, которые требуется отсортировать.
   Принимает одно из значений: `int`, `char`, `str`.
2. Аргумент №2 и последующие: элементы массива, который требуется отсортировать.
   Гарантируется, что все числа помещаются в `int` даже после умножения на три.
   Гарантируется, что внутри строчек и символов используются только ASCII-символы с кодами от 32 до 127, включительно.

Аргументы всегда корректны.
Обратите внимание, что массив может быть пустым, в этом случае аргумент №2 отсутствует.

Приложение должно вывести те же элементы массива, отсортированные по неубыванию, разделённые ровно одним пробелом, на одной строчке.
Какие-либо ещё символы выводить запрещается.
Числа сравниваются по значению, символы — по ASCII-коду, строчки — лексикографически.

Пример работы:

| Команда запуска                    | Вывод                 |
|:---                                |:---                   |
| `./lab_03 int -1 0 2 0 3`          | `-1 0 0 2 3`          |
| `./lab_03 char z y x`              | `x y z`               |
| `./lab_03 str foo bar bazooka baz` | `bar baz bazooka foo` |

### Структура репозитория
```
<корень-личного-репозитория>
|--lab_03
   |--include
   |  |-- mergesort.h
   |--src
   |  |-- main.c
   |  |-- mergesort.c
   |--Makefile
```

Папку `obj`, объектные и исполняемые файлы класть в репозиторий не разрешается.

### Бонусное задание

Как говорилось выше, внутри функции `mergesort` может возникнуть ошибка при выделении памяти (`malloc` вернёт `NULL`).
Вместо обрушения программы через `assert` внутри функции, аккуратно обработайте эту ошибку.

1. Измените функцию `mergesort`, чтобы она возвращала `int`:
   ```
   int mergesort(void *array, size_t elements, size_t element_size, int (*comparator)(const void*, const void*));
   ```
   Как это часто делается в Си, верните `0` в случае успеха и `-1` в случае провала (из-за ошибки выделения памяти).
1. Измените все места вызова функции `mergesort` для корректной обработки возвращаемого значения.
1. При возникновении данной ошибки программа должна вывести единственную строчку `Error: memory allocation failed.` и завершить работу с кодом возврата 1.
   Делать эти действия разрешается *только* в функции `main`.
1. Даже при ошибке выделения памяти, вся успешно выделенная память должна быть освобождена.

Бонус оценивается в **+1** балл. Точные правила уточняйте у своего преподавателя.

## Сроки сдачи

Задание выдано 19.11.2020 (четверг).
Промежуточный срок сдачи — **25.11.2020 (среда) 22:59 по Москве**. 
Крайний срок сдачи — 28.11.2020 (суббота) 22:59 по Москве. 

Если вы не делаете попытку сдачи с корректной [структурой репозитория](#структура-репозитория), собирающимся
кодом и правильно оформленным тикетом в Trac до промежуточного срока сдачи, **вы автоматически получаете ноль баллов** за задание,
даже если потом досылаете полностью корректное решение.

Также на усмотрение преподавателя могут назначаться дополнительные попытки сдачи и дополнительные сроки
проверки.
Например, преподаватель может оперативно проверить решения, отправленные за несколько дней до дедлайна,
и гораздо медленнее — отправленные перед дедлайном.
Уточняйте у своего преподавателя.

