Лабораторная работа №13 (`WW_array`)
====================================

Общее
-----

* Вам требуется реализовать контейнер `my_array`, похожий на [`std::array`](1) и
  хранящий массив элементов типа `T`.
* Этот контейнер представляет собой обёртку над обычным массивом, в частности:
  * Все элементы расположены в памяти друг за другом *внутри* `my_array`
    (а не в динамической памяти, как в случае с `my_vector`).
  * Так как размер любого класса должен быть фиксирован на этапе компиляции,
    количество элементов в `my_array` тоже должно быть фиксировано на этапе
    компиляции. Количество элементов - это отдельный шаблонный параметр `N`.
* Заготовка интерфейса определена в предоставленном вам файле `my_array.h`.
  * Вам запрещается изменять название шаблонного класса или заголовочного файла.
  * Объявления в заготовке, скорее всего, написаны на некотором псевдокоде.
    Вам требуется сделать так, чтобы они компилировались. В частности, вам
    может потребоваться добавить `const`, возвращаемые типы, перегрузки
    имеющихся методов или ещё что-то.
  * `operator[]` и метод `at` ведут себя одинаково с единственным отличием:
    `operator[]` не проверяет переданный индекс на корректность, а `at`
    проверяет. При получении некорректного индекса `at` должен вывести
    сообщение в произвольном формате и завершить работу программы (например,
    при помощи `assert`).
  * Метод `fill` целиком заполняет массив переданным значением. Для этого
    должен использоваться `T::operator=`.
  * Если вы используете функции/типы/константы из стандартной библиотеки,
    то в `my_array.h` должны быть подключены соответствующие заголовочные файлы.

[1]: http://ru.cppreference.com/w/cpp/container/array

Специализация для `bool`
------------------------

Также вам потребуется *частично специализировать* ваш шаблонный класс `my_array`
для `T=bool`. В этом случае:
* `my_array` должен занимать `N/8` байт в памяти (с округлением вверх), то есть
  вам запрещается хранить дополнительные поля.
* Разрешается (и даже потребуется) возвращать прокси-объект с перегруженными
  `operator=` и `operator bool`.
* Вам разрешается создать конструктор внутри этой специализации. Скорее всего,
  вам потребуется это сделать, чтобы избежать потенциального чтения
  неинициализированной памяти даже при нормальном использовании `my_array`.

Ограничения и тестирование
--------------------------

* Ограничения на параметры шаблонного класса:
  * `N > 0`.
  * Можно объявить массив типа `T`.
* Требования, которые должны выполниться автоматически, без дополнительных
  ухищрений:
  * Конструкторы и деструкторы должны вызываться ровно так же, как и в обычном
    массиве. В частности, для тривиальных типов исходное значение элементов
    может быть не определено, а для нетривиальных должно быть вызвано ровно `N`
    конструкторов.
  * Размер (`sizeof`) класса `my_array<T, N>` должен быть равен размеру массива
    из `N` элементов типа `T` (кроме случая `T=bool`).
  * Поведение всех методов должно быть максимально эффектиным и похожим на
    `std::array` (можете консультироваться с документацией).
* Вам предоставлен файл `smoke_compile.cpp` для проверки корректности интерфейса
  вашего `my_array`. Этот файл должен успешно компилироваться при наличии
  корректного `my_array.h` в текущей директории. Например, если вы используете
  компилятор GCC, для проверки вы можете использовать следующую команду:

  ~~~shell
  g++ -std=c++03 -pedantic -Wall -Wextra -Werror smoke_compile.cpp
  ~~~

  Обратите внимание, что этот файл должен компилироваться, даже если вы не
  собираетесь реализовывать специализацию для `bool`.
  
* В вашем репозитории должна появиться папка с названием `lab_13` и следующей
  структурой внутри:

  ~~~
  <корень-репозитория>
  +-- lab_13
      +-- Makefile
      +-- src
      |   +-- main.cpp
      +-- include
          +-- my_array.h
  ~~~

  При этом:
  * При запуске команды `make` под Linux из папки `lab_13` исходный код в
     файле `main.cpp` (и никаких других) должен компилироваться в файл `lab_13`
     в папке `lab_13`. В частности, запуск `make` не должен линковать какие-либо
     файлы, кроме `main.cpp`.
  * `main.cpp` должен подключать файл `my_array.h` при помощи
    `#include "my_array.h"` (а не, например, `#include "../include/my_array.h"`).
    Для этого вы можете передать `g++` при компиляции параметр `-Iinclude`.
  * Остальное содержимое `main.cpp` не важно. Скорее всего, вам потребуется
    реализовать метод `main()` для успешной компиляции. При желании вы можете
    добавить в `main.cpp` свои тесты.
  * При запуске команды `make clean` из папки `lab_13` все промежуточные файлы
    (например, объектные файлы - `*.o`) и исполняемый файл должны удаляться.

Система оценки
--------------

* Задание выдано 08.04.2021 (четверг).
* Промежуточный срок сдачи 15.04.2021 (четверг) 22:59 по Москве.
* Крайний срок сдачи — **17.04.2021 (суббота) 22:59 по Москве**.

Если структура папок в вашем репозитории не соответствует заданию или файл
`smoke_compile.cpp` не компилируется, то вы автоматически получаете 0 баллов.
Вывод компилятора вам будет предоставлен. Дальнейшая проверка будет производиться
только после исправления ошибок компиляции и структуры папок.

Баллы распределяются из расчёта:
* От 0 до 2 баллов - за компилирующийся с `smoke_compile.cpp` код:
  * 1 балл, если имеются предупреждения в режиме
    `-std=c++03 -pedantic -Wall -Wextra`, лог компиляции вам предоставляется.
  * 2 балла, если предупреждения отсутствуют.
* 3 балла - за корректно работающий в общем случае (без специализации для
  `bool`) `my_array`. Частичные баллы не ставятся.
* От 0 до 3 баллов - за корректно работающий `my_array<bool>`.
* От 0 до 2 баллов - за стиль кода.
